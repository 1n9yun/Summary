## 가상메모리

* 프로그램 실행에 필요한 메모리 용량 전체를 Ram에 할당하는 것이 아니라 최소한의 메모리를 Ram에 할당하고 나머지는 HDD(가상메모리)에 저장하는 것

* ### 페이지 폴트

  * 프로그램이 필요로하는 페이지가 물리 메모리에 없을 경우

* ### 요구 페이징

  * 페이지 폴트 시 물리 메모리의 불필요한 페이지와의 교체를 요구
  * 이 과정동안 모든 스레드가 대기

* ### 페이지 교체 알고리즘

  * FIFO
    * 적재된 지 가장 오래된 페이지부터 교체
  * LRU ( Least Recently Used )
    * 가장 오랜 기간 사용되지 않은 페이지를 교체
  * LFU ( Least Frequently Used )
    * 참조 횟수가 가장 적은 페이지를 교체
    * 교체 대상이 여러 개인 경우 LRU를 사용
    * 처음에 집중적으로 참조하다가 이후에 참조하지 않는 경우 계속 메모리에 남아있을 수 있다는 문제점
  * MFU ( Most Frequently Used )
    * 참조 횟수가 가장 많은 페이지를 교체

* ### 메모리 단편화

  * #### 내부 단편화

    * 교체된 페이지의 크기가 할당된 공간의 크기보다 작은 경우
    * 저장 공간 낭비

  * #### 외부 단편화

    * 메모리가 할당되고 해제되는 과정에서 작은 메모리가 중간중간 존재
    * 이 때 총 메모리 공간은 충분하지만 교체된 페이지의 크기가 할당된 공간의 크기보다 큰 경우

  * #### 해결

    * ##### 페이징

      * 페이지가 연속적인 물리 메모리 공간에 들어가야 하는 제약을 해결하기 위한 방법
      * 가상 메모리는 페이지, 물리 메모리는 프레임이라는 고정 크기의 블록으로 나눈다.
      * 페이지 테이블의 매핑을 통해 1:1 대응
      * 외부 단편화 해결
      * 페이지 단위를 작게하면 내부 단편화 역시 해결할 수 있지만 페이지에 공간을 할당한 후 남는 공간이 적어지기 때문에 그 만큼 page mapping 과정이 증가할 수 있다.

    * ##### 세그먼테이션

      * 프로그램의 논리적 단위를 바탕으로 서로 다른 크기의 블록으로 나누는 방법
      * 내부 단편화 해결