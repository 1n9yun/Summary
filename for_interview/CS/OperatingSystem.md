# Operating System

## Process

* 실행중에 있는 프로그램

* 프로세스 내부에는 최소 하나의 스레드, 실제로는 스레드 단위로 스케줄링

* 하드디스크에 있는 프로그램을 실행하면, 실행을 위해 메모리 할당이 이루어지고, 할당된 메모리 공간으로 바이너리 코드가 올라간다. 이 때 프로세스라 불린다.

* ### 구조  

  * Code 영역
    * 프로그램을 실행시키는 실행 파일 내의 명령어들이 올라감(쉽게 소스코드)
  * Data 영역
    * 전역 변수, static 변수의 할당
  * Heap 영역
    * 동적할당을 위한 메모리 영역
  * Stack 영역
    * 지역변수, 함수 호출시 전달되는 파라미터를 위한 메모리 영역
  
* ### 멀티

  * 하나의 프로그램을 여러 프로세스로 구성하여 Context Switching을 통해 실행하는 것
  * 하나의 프로세스에 문제가 생기더라도 다른 프로세스에 영향을 미치지 않는다.

* ### Context Swtiching

  * 인터럽트에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존 프로세스의 상태 또는 레지스터 값을 저장
  * 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값을 교체하는 작업

* ### 교착 상태

  * 서로 다른 프로세스가 서로의 자원을 요구하며 무한정 기다리는 현상

  * #### 조건

    * 상호 배제 : 한 번에 한 프로세스만이 자원을 점유할 수 있다.
    * 점유 대기 : 프로세스가 이미 자원을 점유하는 상태에서 다른 자원을 무한정 기다린다.
    * 비선점 : 프로세스가 어떤 자원의 점유를 끝낼 때 까지 그 자원을 뺏을 수 없다.
    * 순환 대기 : 각 프로세스들이 원형으로 구성되어 순환적으로 자원을 요구한다.



## Thread

* 프로세스 내에서 동작되는 실행의 단위

* Stack 외에 프로세스가 할당받은 자원을 스레드끼리 공유

* 하나의 프로세스가 실행되면 기본적으로 하나의 메인 스레드가 생성된다.

* ### 멀티

  * 하나의 프로그램을 한 프로세스 내에 여러 개의 스레드로 구성하여 실행하는 것
  * 멀티 프로세스보다 멀티 스레드가 더 효율적
  * 스레드 간의 통신 비용이 훨씬 적기 때문
  * 하지만 스레드 간의 자원 공유는 전역 변수를 이용하기에 동기화를 신경 써야 함

* ### ThreadLocal

  * 스래드 내부에서 사용되는 지역 변수
  * 각각의 thread scope 내에서 공유되어 사용될 수 있는 값으로 다른 스레드에서 공유 변수에 접근할 시 발생할 수 있는 동시성 문제의 예방을 위해 만들어짐



## 뮤텍스와 세마포어

* 다수의 프로세스나 스레드가 공유 자원을 동시에 접근하는 것을 제어하는 것

* ### 뮤텍스

  * 한 스레드, 프로세스에 의해 소유될 수 있는 Key를 기반으로 한 상호배제 기법
  * 한 스레드가 임계 영역에 들어갈 때 lock을 걸어 다른 스레드가 접근하지 못하게 하고 임계 영역에서 나올 때 unlock 한다.

* ### 세마포어

  * 현재 공유 자원에 접근할 수 있는 스레드, 프로세스의 수를 나타내는 값을 두는 상호 배제 기법



## 가상메모리

* 프로그램 실행에 필요한 메모리 용량 전체를 Ram에 할당하는 것이 아니라 최소한의 메모리를 Ram에 할당하고 나머지는 HDD(가상메모리)에 저장하는 것

* ### 페이지 폴트

  * 프로그램이 필요로하는 페이지가 물리 메모리에 없을 경우

* ### 요구 페이징

  * 페이지 폴트 시 물리 메모리의 불필요한 페이지와의 교체를 요구
  * 이 과정동안 모든 스레드가 대기

* ### 페이지 교체 알고리즘

  * FIFO
    * 적재된 지 가장 오래된 페이지부터 교체
  * LRU ( Least Recently Used )
    * 가장 오랜 기간 사용되지 않은 페이지를 교체
  * LFU ( Least Frequently Used )
    * 참조 횟수가 가장 적은 페이지를 교체
    * 교체 대상이 여러 개인 경우 LRU를 사용
    * 처음에 집중적으로 참조하다가 이후에 참조하지 않는 경우 계속 메모리에 남아있을 수 있다는 문제점
  * MFU ( Most Frequently Used )
    * 참조 횟수가 가장 많은 페이지를 교체

* ### 메모리 단편화

  * #### 내부 단편화

    * 교체된 페이지의 크기가 할당된 공간의 크기보다 작은 경우
    * 저장 공간 낭비

  * #### 외부 단편화

    * 메모리가 할당되고 해제되는 과정에서 작은 메모리가 중간중간 존재
    * 이 때 총 메모리 공간은 충분하지만 교체된 페이지의 크기가 할당된 공간의 크기보다 큰 경우

  * #### 해결

    * ##### 페이징

      * 페이지가 연속적인 물리 메모리 공간에 들어가야 하는 제약을 해결하기 위한 방법
      * 가상 메모리는 페이지, 물리 메모리는 프레임이라는 고정 크기의 블록으로 나눈다.
      * 페이지 테이블의 매핑을 통해 1:1 대응
      * 외부 단편화 해결
      * 페이지 단위를 작게하면 내부 단편화 역시 해결할 수 있지만 페이지에 공간을 할당한 후 남는 공간이 적어지기 때문에 그 만큼 page mapping 과정이 증가할 수 있다.

    * ##### 세그먼테이션

      * 프로그램의 논리적 단위를 바탕으로 서로 다른 크기의 블록으로 나누는 방법
      * 내부 단편화 해결