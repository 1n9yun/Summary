# 가상메모리

프로그램 실행에 필요한 메모리 용량 전체를 Ram에 할당하는 것이 아니라 최소한의 메모리를 Ram에 할당하고 나머지는 HDD(가상메모리)에 저장하는 것

## 페이지 폴트

프로그램이 필요로하는 페이지가 물리 메모리에 없을 경우

## 요구 페이징

페이지 폴트 시 물리 메모리의 불필요한 페이지와의 교체를 요구, 이 과정동안 모든 스레드가 대기

## 페이지 교체

* CPU가 프로세스 A의 페이지 A<sub>5</sub>를 참조한다.
* 프로세스 A의 페이지 테이블에서 A<sub>5</sub>가 무효상태임을 확인
* 교체 알고리즘이 프레임 M에 있는 페이지 B<sub>3</sub>을 교체 대상으로 선정, 스왑 아웃한다.
* B<sub>3</sub>의 페이지 테이블 항목을 무효화
* A<sub>5</sub>를 프레임 M에 적재한다.
* A<sub>5</sub>의 페이지 테이블 항목에 프레임 번호 M을 표시하고 유효 상태로 바꾼다.

### 페이지 교체 알고리즘

* OPT( 최적 페이지 교체 )
  * 물리적 메모리에 존재하는 페이지 중 가장 먼 미래에 참조될 페이지를 쫓아낸다.
  * 구현의 어려움, 다른 알고리즘의 성능에 대한 상한선의 역할

  * FIFO
    * 적재된 지 가장 오래된 페이지부터 교체
  * LRU ( Least Recently Used )
    * 가장 오랜 기간 사용되지 않은 페이지를 교체
  * LFU ( Least Frequently Used )
    * 참조 횟수가 가장 적은 페이지를 교체
    * 교체 대상이 여러 개인 경우 LRU를 사용
    * 처음에 집중적으로 참조하다가 이후에 참조하지 않는 경우 계속 메모리에 남아있을 수 있다는 문제점
  * MFU ( Most Frequently Used )
    * 참조 횟수가 가장 많은 페이지를 교체

## 메모리 단편화

### 내부 단편화

* 교체된 페이지의 크기가 할당된 공간의 크기보다 작은 경우
* 저장 공간 낭비

### 외부 단편화

* 메모리가 할당되고 해제되는 과정에서 작은 메모리가 중간중간 존재
* 이 때 총 메모리 공간은 충분하지만 교체된 페이지의 크기가 할당된 공간의 크기보다 큰 경우

### 해결
#### 페이징

* 페이지가 연속적인 물리 메모리 공간에 들어가야 하는 제약을 해결하기 위한 방법
* 가상 메모리는 페이지, 물리 메모리는 프레임이라는 고정 크기의 블록으로 나눈다.
* 페이지 테이블의 매핑을 통해 1:1 대응
* 외부 단편화 해결
* 페이지 단위를 작게하면 내부 단편화 역시 해결할 수 있지만 페이지에 공간을 할당한 후 남는 공간이 적어지기 때문에 그 만큼 page mapping 과정이 증가할 수 있다.

#### 세그먼테이션

* 프로그램의 논리적 단위를 바탕으로 서로 다른 크기의 블록으로 나누는 방법
* 내부 단편화 해결